<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>zKTT - Zero Knowledge Table Top</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A zero knowledge proof table-top game deployed onchain.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="lexicon.html"><strong aria-hidden="true">1.</strong> Lexicon</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">2.</strong> Macros</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.</strong> Installation</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">4.</strong> Configuration</a></li><li class="chapter-item expanded affix "><li class="part-title">Storage</li><li class="chapter-item expanded "><a href="dojo_storage.html"><strong aria-hidden="true">5.</strong> Storage in Dojo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="entities.html"><strong aria-hidden="true">5.1.</strong> Entities</a></li><li class="chapter-item expanded "><a href="models.html"><strong aria-hidden="true">5.2.</strong> Models</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Contracts</li><li class="chapter-item expanded "><a href="contracts.html"><strong aria-hidden="true">6.</strong> Basic Template</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="world_contract.html"><strong aria-hidden="true">6.1.</strong> World Contract</a></li><li class="chapter-item expanded "><a href="read_contracts.html"><strong aria-hidden="true">6.2.</strong> Read Contracts</a></li><li class="chapter-item expanded "><a href="write_contracts.html"><strong aria-hidden="true">6.3.</strong> Invoke Contracts</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Permissions</li><li class="chapter-item expanded "><a href="permissions.html"><strong aria-hidden="true">7.</strong> Permissions on Models</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overlays.html"><strong aria-hidden="true">7.1.</strong> Overlays</a></li><li class="chapter-item expanded "><a href="sozo_grant.html"><strong aria-hidden="true">7.2.</strong> Sozo grant</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Testing</li><li class="chapter-item expanded "><a href="unit_tests.html"><strong aria-hidden="true">8.</strong> Unit Testing with Dojo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy_world_test.html"><strong aria-hidden="true">8.1.</strong> Deploying a World</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">8.2.</strong> Test Cheatsheet (Coming Soon)</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Deployment</li><li class="chapter-item expanded "><a href="devnet.html"><strong aria-hidden="true">9.</strong> DevNet</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">10.</strong> Slot (Coming Soon)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zKTT - Zero Knowledge Table Top</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zktt-docs"><a class="header" href="#zktt-docs">zKTT Docs</a></h1>
<p>Welcome to the <a href="https://github.com/webisoftSoftware/zktt">zKTT</a> docs page where all the more in-depth and technical aspects of the zKTT codebase will be discussed and explained for developers looking to use the <a href="https://book.dojoengine.org/toolchain/sozo/world-commands/execute">Dojo</a> framework to build or <br />
improve onchain contracts in the <a href="https://book.starkli.rs/installation">Starknet</a> ecosystem. Essentially, the 'whys' and 'hows' for specific cairo and dojo syntax will be explored and you can expect anything ranging from developer notes, to advanced cairo topics and feature discussions to be included in this book.</p>
<p>This book assumes that you have prior knowledge of Blockchain, specifically for <a href="https://docs.starknet.io/">Starknet</a>, as well as some experience with its contract language - <a href="https://book.cairo-lang.org/ch14-00-building-starknet-smart-contracts.html">Cairo</a>. If you don't know one of these topics or need a refresher, we suggest you take a look at these helpful resources to get up to speed before proceeding.</p>
<h3 id="relevant-resources"><a class="header" href="#relevant-resources">Relevant Resources:</a></h3>
<p>Dojo docs: <a href="https://book.dojoengine.org/toolchain/sozo/world-commands/execute">https://book.dojoengine.org</a><br />
zKTT github repo: <a href="https://github.com/webisoftSoftware/zktt/">https://github.com/webisoftSoftware/zktt</a><br />
Cairo Book: <a href="https://book.cairo-lang.org/ch14-00-building-starknet-smart-contracts.html">https://book.cairo-lang.org</a><br />
Cairo Advanced Topics: <a href="https://cairopractice.com/">https://cairopractice.com</a><br />
Starknet Book: <a href="https://book.starknet.io/ch03-00-architecture.html">https://book.starknet.io</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexicon"><a class="header" href="#lexicon">Lexicon</a></h1>
<p>First things first, let's talk about the basic semantics that dojo brings to the table. Most notably, its <strong>ECS</strong> to store and retrieve data onchain. We won't go into too much details regarding the definitions and theory behind Dojo's <strong>ECS</strong>. We will instead go more in-depth over the implementation details, as the docs fail to notify first-time users about certain features and pitfalls.</p>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<p><em>You may see the word <strong>components</strong> being thrown around in some of the linked documentations or in this guide. In this context, the word is just a simple synonym for <strong>models</strong> and can be interchanged with it at any point.</em></p>
<ul>
<li><strong>Katana</strong> is the <strong>sequencer</strong> that acts as devnet onchain to simulate an onchain environment. Used mainly for testing unless paired with <strong>Slot</strong></li>
<li><strong>Torii</strong> is the <strong>indexer</strong> that deserializes incoming data onchain, useful for reading events triggered by the world and querying model states</li>
<li>Every dojo <strong>world</strong> is a <strong>centralized Starknet contract</strong> that contains a set of contracts</li>
<li>Every <strong>system</strong> is a <strong>function or selector</strong> in a dojo contract</li>
<li>A component or <strong>model</strong> in Dojo is just a Cairo struct with automatic on-chain introspection</li>
<li>Every <strong>model</strong> must contain at least <strong>one key</strong>. A <strong>model</strong> can contain multiple <strong>keys</strong> as long as there is at least <strong>one element that is not a key</strong></li>
<li><strong>Entities</strong> are defined by the <strong>keys</strong> inside the models that associate with them</li>
</ul>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<ul>
<li>Both Katana and Torii have an allowed-cors argument that is useful for whitelisting/blacklisting domains</li>
<li>Torii doesn't need to run if you simply want to execute contracts in your world. If there is a third party that wants to read data from onchain however, it is strongly recommended to have it running</li>
<li>Dojo contracts all live within the centralized world contract, most likely as class hashes in its storage</li>
<li>Dojo models are stored as key-value pairs in storage in the <strong>world</strong> they reside, like in a Map</li>
<li>Your world <strong>emits events</strong> that are sent to <strong>Katana</strong> as transactions, then <strong>Torii captures these events</strong>, indexes them in its db, and proceeds to deserializing the event contents for anyone listening on those that wants to have the state change in a API-like format</li>
<li>Although missing from the Dojo docs, <strong>read selectors</strong> are supported for Dojo contracts to read from storage (more on that in <a href="cairo-to-dojo-starter.html#setting-up-systems">Setting up Systems</a>)</li>
</ul>
<p>First, let's address the elephant in the room - what the hell are those macros above the models used for? </p>
<p>If you have tackled some <strong>Rust</strong> before, then you're almost there! You only need to learn about the additional macros that dojo provides. If you are trembling in your boots at the sight of the above macros, then don't worry, we will dissect each one together:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The derive <a href="https://doc.rust-lang.org/reference/procedural-macros.html"><strong>procedural macro</strong></a> allows developers to have code tied to the <em>struct</em> already generated for them so that they can save time and not have to <em>reinvent the wheel</em>.</p>
<p>For the <em>Character</em> model in the above code snippet, here's what each element in the <strong>derive</strong> macro means:</p>
<ul>
<li><strong>Drop</strong> (<em>Mandatory</em>): Tells the compiler that this data structure (and every field inside of it) is droppable - i.e. can be removed from a scope. Generates the <code>Drop()</code> function for us</li>
<li><strong>Serde</strong> (<em>Mandatory</em>): Marks this struct (and every field inside of it) as serializable/deserializable - can be written to a file, which in our case will be the manifest files with the ABI in a JSON format. Generates the <code>serialize()</code> and <code>deserialize()</code> functions for us</li>
<li><strong>Clone</strong>: Marks the struct (and every field inside of it) can be cloned, when trying to pass the data to a function <strong>without consuming the model itself</strong>. Generates the <code>clone()</code> function for us</li>
<li><strong>PartialEq</strong>:  Signals the compiler that this struct  (and every field inside of it) can be compared with the <code>==</code> symbol with the same type. Generates the <code>eq()</code> and <code>ne()</code> functions for us</li>
<li><strong>Debug</strong>: Notify the compiler that this struct (and every field inside of it) can be printed using the <code>{:?}</code> format specifier - i.e. in <code>println!()</code> which will print the struct with all of its fields in a <em>Rust-style</em> way</li>
</ul>
<p>You may have noticed that in the components file, there are enums, which derive of another <strong>Trait</strong> - <strong>Introspect</strong>. <em>Introspect is there</em> to tell sozo that this enum may be introspected when invoking contracts with it as calldata. <em>Introspect</em> is automatically included with <code>#dojo::model]</code>,  however for structures that are not a <strong>dojo model</strong>, we need to manually specify it.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<h3 id="get"><a class="header" href="#get">get!()</a></h3>
<p>The macro <code>get!()</code> is a builtin macro provided by <code>#[dojo::contract]</code>, and allows us to fetch the <strong>model</strong> <em>Character</em> associated with the <strong>entity</strong> <em>caller</em>, which is just a typical Starknet contract address. The reason why <em>caller</em> and <em>Character</em> are between parentheses, is due to how Dojo's <em>get!()</em> macro expects entities and models. It requires that both the <strong>keys</strong> (entity) and the models passed be in tuples</p>
<p>You can also fetch multiple models against an entity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get both character and inventory models for the caller at the same time.
// Note that this will ONLY work if BOTH Character and Inventory have the SAME
// primary key type (contractAddress).
let (character, inventory) = get!(world, (caller), (Character, Inventory));
<span class="boring">}</span></code></pre></pre>
<h3 id="set"><a class="header" href="#set">set!()</a></h3>
<p>The macro <code>set!()</code> is a builtin macro provided by <code>#[dojo::contract]</code>, and allows us to <strong>write</strong>
the <strong>model</strong> <em>Character</em> and <em>Inventory</em> associated with the <strong>entity</strong> <em>caller</em>. Note that the <code>set!()</code>
macro does <strong>not</strong> need the model types in a separate tuple to be provided in the call arguments.</p>
<p>You can also set multiple models at once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// By default, a system will be one able to write and mutate the world, it is 
// essentially an invoke transaction on the selector 'get_character_name'
fn set_character_name(ref world: IWorldDispatcher, new_name: ByteArray) {
    let caller = get_caller_address();
    // Get the current character that we want to mutate.
    let mut character = get!(world, (caller), (Character));
    // Making sure that the caller has a character.
    assert!(*character.m_name != "", "Character not found");
    character.m_name = new_name;
    set!(world, (character));  // We set the new state of the character model in our world
}
<span class="boring">}</span></code></pre></pre>
<p>Notice how we don't have to specify the <strong>model</strong> <strong>types</strong>? The <code>set!()</code> macro allows us to only provide the modified model instance, in any order as we want this time, regardless of how many different model instances we give it, as long as the model instances' types are valid dojo <strong>models</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="importing-dojo"><a class="header" href="#importing-dojo">Importing Dojo</a></h2>
<p>There are currently three main ways to import the Dojo toolset onto your codebase:</p>
<ul>
<li>Cloning the <a href="https://github.com/dojoengine/dojo"><strong>repo</strong></a> directly and building from source</li>
<li>Using the <a href="https://book.dojoengine.org/getting-started#install-dojo-using-dojoup"><strong>Dojoup</strong></a> version manager</li>
<li>Using the <a href="https://book.dojoengine.org/getting-started#install-asdf"><strong>asdf</strong></a> package manager</li>
</ul>
<p>All the links provided will guide you through installation when using <strong>Dojoup</strong> or <strong>asdf</strong>. However, Dojo docs don't go over installing from source, so here's a quick guide filling in the blanks.</p>
<h3 id="build-from-source-with-cargo"><a class="header" href="#build-from-source-with-cargo">Build from Source with Cargo</a></h3>
<ul>
<li>After cloning, use <strong>Cargo</strong> to install <strong>Sozo, katana, and Torii</strong>:</li>
</ul>
<pre><code class="language-bash">$ cd dojo 
$ cargo install --locked --path ./bin/sozo 
$ cargo install --locked --path ./bin/katana 
$ cargo install --locked --path ./bin/torii
</code></pre>
<ul>
<li>Put all three in your <strong>local</strong> <strong>user binaries</strong> to ensure that your shell refers find these programs: </li>
</ul>
<pre><code class="language-bash">$ sudo mkdir -p /usr/local/bin
$ sudo cp ./target/release/sozo ./target/release/katana ./target/release/torii \
  /usr/local/bin
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>If we take the project structure from the <a href="https://github.com/webisoftSoftware/zktt/"><strong>zKTT</strong> </a>repo as reference, here's how the file structure could look like upon creating an initial dojo project:</p>
<pre><code>zktt/
|── assets                           # Contains all the assets (textures, images, fonts, etc...).
|── manifests
    └── dev/
        └── base/                    # Contains the the base manifests of the world (auto-generated).
            └── abis/                # Contains base world system, event, and model ABIs (generated after sozo build).
            |── dojo-base.toml    
            └── dojo-world.toml
        └── deployment/
            └── abis/
                └── contracts/       # Contains all contract ABIs (generated after sozo build).
                └── models/          # Contains all model ABIs (generated after sozo build).
                |── dojo-base.json    
                └── dojo-world.json
            |── manifest.json        # Contains the all the world data manifest (generated after sozo build).
            └── manifest.toml        # Contains any added values in the dojo-dev/dojo-release.toml (generated after sozo build)
|── overlays
    └── dev/
        |── table.toml               # Contains all permissions for writing to models in the zktt-table contract.
├── src/
    └── models/                      # Model source directory.
    └── systems/                     # System source directory.
    └── tests/                       # Integration tests go here.
        ├── test_basic.cairo            
        └── lib.cairo                # Test module.
    └── lib.cairo                    # Root module.
├── Scarb.toml                       # Project's manifest file, contains metadata and dependencies.
├── Scarb.lock
├── dojo-dev.toml                    # Config for release profile .
├── dojo-release.toml                # Config for dev profile.
</code></pre>
<h3 id="dojo-manifests"><a class="header" href="#dojo-manifests">Dojo Manifests</a></h3>
<p>Below is an example of what to minimally include in the main <strong>Scarb.toml</strong> file located at the root of the dojo project directory.</p>
<pre><code class="language-toml">[package]
name = "project_example"  # Your preferred world name
version = "1.0.0"  # Your project's preferred version scheme.

# Need to import dojo. Tag version should match the release version on github.
# NOTE: Make sure that Sozo and Katana match versions, otherwise migrating to katana will fail.
[dependencies]
starknet = "2.7.0"  # Need to force cairo to be version 2.7.0 (latest supported version as of the day writing this)
dojo = {git = "https://github.com/dojoengine/dojo"}  # Fetch latest version.

# Needed to point to dojo_*.toml for sozo commands like migrate apply, grant, execute, etc...
[[target.dojo]]
</code></pre>
<p>Furthermore, <strong>dojo_dev.toml</strong> and <strong>dojo_release.toml</strong> are manifest files that contain the configuration needed by sozo for <strong>deployment</strong>. Dojo-dev only firing for the dev builds and release only being applied for release builds.<br />
<br />
Example dev manifest:</p>
<pre><code class="language-toml">// Example dojo_dev.toml

[world]
name = "Example World"
description = "Powered by Starknet and Dojo"
cover_uri = "file://assets/cover.png"
icon_uri = "file://assets/icon.png"

[namespace]
default = "test"  # This will be useful when setting permissions.

[env]
# Default port assigned to Katana, when starting the server.
# Change this if you plan on starting the Katana server on a custom port.
rpc_url = "http://localhost:5050/"
# Default account for katana with seed = 0
account_address = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec"
private_key = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912"
# Remove this line upon first deployment and put it back with your newly created
# world contract hash upon successful deployment to be able to interact with 
# Torii and Katana properly.
world_address = "0x55fe412440c3303d253485ed7486dafd735b1b0b3a3563fa8e3f7410efffff"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-in-dojo"><a class="header" href="#storage-in-dojo">Storage in Dojo</a></h1>
<p>Dojo's 'storage' is actually included in the <code>#[dojo::contract]</code> macro, and all we need to do to write
and read from it is to use the <code>get!()</code> and <code>set!()</code> macros instead of the classic <code>.write()</code> and <code>.read()</code>
functions onto the storage variables directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>As far as Dojo is concerned, <em>entities</em> are just <strong>keys</strong> that map to the <strong>models</strong> in storage.
In Dojo's docs, there are clear set rules that need to be followed when marking <em>fields</em> as <em>keys</em>:</p>
<ul>
<li>There must be <strong>at least one</strong> key per model's data</li>
<li>There needs to be <strong>at least one field</strong> that is not an entity (key)</li>
<li><strong>Every</strong> key needs to be passed in when using the <code>get!()</code> macro for the model containing those keys</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models"><a class="header" href="#models">Models</a></h1>
<p>In order to set up your contracts in your Dojo world, I recommend designing the systems around the entities and models instead of the inverse. By clearly defining what the models are going to require data-wise, and what they represent, you can implement the systems that are going to work around them more easily and efficiently, without going back and forth every time the models change - as this is inevitable as compute and storage requirements evolve during development.</p>
<h3 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h3>
<p>Here's a small and barebones minecraft clone to provide as an example of real applications using Dojo as we explain the basic boilerplate code to append to your models and entities to make them work with Katana and Torii:</p>
<h4 id="modelscomponentscairo"><a class="header" href="#modelscomponentscairo">models/components.cairo</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All models supported in the game and stored onchain.

#[derive(Drop, Clone, Serde, PartialEq, Debug)]
#[dojo::model]
struct Character {
    #[key]
    m_ent_player_addr: ContractAddress,  // Who this character belongs to.
    m_alias: ByteArray,  // The name that they have chosen to display to others.
    m_player_index: u8  // The nth player in the world.
}

#[derive(Drop, Clone, Serde, PartialEq, Debug)]
#[dojo::model]
struct Inventory {
    #[key]
    m_ent_player_addr: ContractAddress,
    m_size: u32,
    m_stack_limit: u32,
    m_items: Array&lt;BlockType&gt;
}

#[derive(Drop, Clone, Serde, PartialEq, Debug)]
#[dojo::model]
struct Hotbar {
    #[key]
    m_ent_inventory_addr: ContractAddress,
    m_items: Array&lt;BlockType&gt;
}

#[derive(Drop, Copy, Serde, PartialEq, Debug, Introspect)]
enum BlockType {
    Grass: (),
    Wood: (),
    Water: (),
    Stone: (),
    Ore: OreType
    // etc...
}

#[derive(Drop, Copy, Serde, PartialEq, Debug, Introspect)]
enum OreType {
    Diamond,
    Gold,
    Iron,
    Coal
    // etc...
}

 
// And way more... 
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-setup"><a class="header" href="#contract-setup">Contract Setup</a></h1>
<h3 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h3>
<p>First up, just like a typical Cairo contract, you need to set up your contract interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All the systems relevant to the minecraft example world 
// used in the previous code snippets

#[dojo::interface]
trait IWhatever {
    // Add your trait functions here...
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[dojo::interface]</code> acts very much like the <code>#[starknet::interface]</code>, the only difference seems to be that the former has <em>IWorldDIspatcher</em> defined,  making it possible for systems defined within the interface block to use the world as a parameter.</p>
<h3 id="systems"><a class="header" href="#systems">Systems</a></h3>
<p>There are two types of systems in a dojo contract, just like in a typical Cairo contract: <strong>read</strong> and <strong>write</strong> contracts.
Below is a minimal example of how to structure a Dojo contract so that the world can call upon that contract (i.e. with <code>sozo execute</code>).  Every contract that interacts with the world should be placed under the <strong>src/</strong> folder to get picked up by sozo when compiling.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic (and incomplete) Dojo contract template with a rock/paper/scissors game.

use starknet::ContractAddress;
use project_example::models::Choice;

#[dojo::interface]  // MANDATORY
trait IRPS {
    fn join(ref world: IWorldDispatcher) -&gt; ();
    fn start(ref world: IWorldDispatcher) -&gt; ();
    fn play(ref world: IWorldDispatcher, player_one_move: Choice,
        player_two_move: Choice) -&gt; ();
    fn leave(ref world: IWorldDispatcher) -&gt; ();
}

#[dojo::contract]  // MANDATORY
mod rps {
    use starknet::ContractAddress;
    use project_example::models::Choice;
    
    // All internal functions (not visible in the ABI).
    //
    // OPTIONAL
    fn _determine_winner(player_one_move: Choice, player_two_move: Choice) -&gt; u8 {
        return match (player_one_move, player_two_move) {
            (Choice::Rock, Choice::Paper) =&gt; 2,        // Second player wins.
            (Choice::Rock, Choice::Rock) =&gt; 0,         // Tie.
            (Choice::Paper, Choice::Rock) =&gt; 1,        // First player wins.
            (Choice::Rock, Choice::Scissor) =&gt; 1,      // First Player wins.
            (Choice::Scissor, Choice::Rock) =&gt; 2,      // Second player wins.
            (Choice::Scissor, Choice::Paper) =&gt; 1      // First player wins.
            (Choice::Paper, Choice::Scissor) =&gt; 2,     // Second player wins.
            (Choice::Scissor, Choice::Scissor) =&gt; 0,   // Tie.
        };
    }
    
    // This internal init function acts as a constructor, where it will only be 
    // ran once, when the contract is deployed.
    //
    // OPTIONAL
    fn dojo_init(ref world: IWorldDispatcher) {
        // Do Something that should only be ran once and at the beginning...
    }
    
    // All public functions (visible in the ABI).
    #[abi(embed_v0)]
    impl IRPSImpl of IRPS&amp;#x3C;ContractState&gt; {
        // MANDATORY
        fn join(ref world: IWorldDispatcher) -&gt; () {
            //  Add logic...
        }
        
        // MANDATORY
        fn start(ref world: IWorldDispatcher) -&gt; () {
            //  Add logic...
        }
        
        // MANDATORY
        fn play(ref world: IWorldDispatcher, player_one_move: Choice,
            player_two_move: Choice) -&gt; () {
            //  Add logic...
        }
        
        // MANDATORY
        fn leave(ref world: IWorldDispatcher) -&gt; () {
            //  Add logic...
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><i>Note: It is strongly recommended to treat your dojo contracts, as specific <strong>actions</strong> and <strong>behaviors</strong> that your world will need to have. You should separate contracts and condense them as much as possible to favor composability as opposed to a 'main' contract that will hold all the logic of the world.</i></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world-contract"><a class="header" href="#world-contract">World Contract</a></h1>
<h3 id="iworlddispatcher"><a class="header" href="#iworlddispatcher">IWorldDispatcher</a></h3>
<p>You probably have some questions regading this infamous <strong>IWorldDispatcher</strong> contract that we have been passing around in the dojo systems above. The <strong>world contract</strong> is a dojo-defined contract that defines the world in which the dojo contracts and models will reside in. It is just like any contract: it has its own interface, implementation and storage (which will be used throughout the lifetime of our project). As a result, just like any other starknet contract in Cairo, you can import it's <strong>dispatcher</strong> and <strong>interface</strong> (<strong>IWorldDispatcher, IWorldDispatcherTrait</strong>). </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-contracts"><a class="header" href="#read-contracts">Read Contracts</a></h1>
<h4 id="read-or-view-systems"><a class="header" href="#read-or-view-systems">Read or View Systems</a></h4>
<p>In Dojo, you can mark a system in your contract to be viewable (does not invoke and mutate storage onchain): </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mark function as 'read-only'.
#[view]
// Notice the '@' symbol before the IWorldDispatcher? That is intentional and required.
// You can append as many parameters as you want.
fn get_character_name(world: @IWorldDispatcher) -&gt; ByteArray {
    let caller = get_caller_address();
    let character = get!(world, (caller), (Character));
    // Making sure that the caller has a character.
    assert!(*character.m_name != "", "Character not found");
    return character.m_name.clone();
}
<span class="boring">}</span></code></pre></pre>
<p>If you are confused about the <code>get!()</code> macro and it's usage here, refer to the <a href="./macros.html">macros</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invoke-contracts"><a class="header" href="#invoke-contracts">Invoke Contracts</a></h1>
<p>In Dojo, <em>write</em> contracts are just regular systems that can mutate the world by setting some
models to a new state onchain.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// By default, a system will be one able to write and mutate the world, it is 
// essentially an invoke transaction on the selector 'get_character_name'
fn set_character_name(ref world: IWorldDispatcher, new_name: ByteArray) {
    let caller = get_caller_address();
    // Get the current character that we want to mutate.
    let mut character = get!(world, (caller), (Character));
    // Making sure that the caller has a character.
    assert!(*character.m_name != "", "Character not found");
    character.m_name = new_name;
    set!(world, (character));  // We set the new state of the character model in our world
}
<span class="boring">}</span></code></pre></pre>
<p>If you are confused about the <code>set!()</code> macro and it's usage here, refer to the <a href="./macros.html">macros</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions"><a class="header" href="#permissions">Permissions</a></h1>
<p>Every Dojo world can have permissions so that certain models in the world storage can/can't be written to. This is useful if we need to enforce some contracts to not be able to mutate models to maintain integrity depending on the logic implemented.</p>
<p>All the Dojo systems within every contract in the world will <strong>not</strong> be able to write to models by default. Thus, you need to whitelist systems or contracts if your contracts mutate the world models (which they  almost always do).</p>
<p>There are two ways to set permissions on Dojo models:</p>
<ol>
<li>
<p> Using <strong>overlays</strong> in the <strong>overlays/</strong> directory</p>
</li>
<li>
<p>Using <code>sozo execute grant owner/writer</code> to manually set permissions on models in the command-line <strong>after</strong> migrating the world onto Katana.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overlays"><a class="header" href="#overlays">Overlays</a></h1>
<p>Overlays are are neat way to configure in a manifest file all the models you wish to authorize
your world of <em>writing</em> and <em>owning</em>.</p>
<p>Using <strong>overlays</strong> in the <strong>overlays/</strong> directory</p>
<pre><code class="language-toml"># Allow all systems within the 'tag' (contract) specified to write to all of our models.

# Example project -&gt; test
# Example contract within test -&gt; apply
# Example systems within the apply contract -&gt; [join, leave, print, copy, save]
# Example models in test -&gt; [Player, Server, Move, Spawn, Respawn].

tag = "test-apply"    # Apply these permissions for the 'apply' contract within 'test'.
writes = ["ns:test"]  # Be able to write to all models within the namespace (ns) 'test'.

For more info on how authorization works in the Dojo ecosystem, the[ Dojo docs](https://book.dojoengine.org/framework/world/authorization) go over it in details.</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sozo-grant"><a class="header" href="#sozo-grant">Sozo grant</a></h1>
<p>You can manually set permissions on models in your world by invoking the <strong>grant</strong> command from
<em>sozo</em> <strong>after</strong> you have migrated your world onto your Katana instance.</p>
<p>Using <code>sozo execute grant owner/writer</code>:</p>
<pre><code class="language-bash">$ sozo auth grant writer model:Player, "&lt;deployed world contract hash&gt;"
$ sozo auth grant writer model:Server, "&lt;deployed world contract hash&gt;"
$ sozo auth grant writer model:Move, "deployed world contract hash"
$ sozo auth grant writer model:Spawn, "&lt;deployed world contract hash&gt;"
$ sozo auth grant writer model:Respawn, "&lt;deployed world contract hash&gt;"
</code></pre>
<p>For more info on how authorization works in the Dojo ecosystem, the<a href="https://book.dojoengine.org/framework/world/authorization"> Dojo docs</a> go over it in details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing-with-dojo"><a class="header" href="#unit-testing-with-dojo">Unit Testing with Dojo</a></h1>
<p>Dojo (sozo test) uses <strong>scarb test</strong> under the hood to test the functions provided under the <strong>tests/</strong> directory (each test needing the <code>#[test]</code> in order to get picked up as tests during compilation).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-a-world"><a class="header" href="#deploying-a-world">Deploying a World</a></h1>
<p>One important feature provided by the Dojo framework for testing is the helper functions <code>spawn_test_world</code> and <code>deploy_contract</code>. These allow us to simulate a world deployment, which is very useful when trying to test the flow of transactions between your dojo contracts and onchain.<br />
<br />
Here is a minimal template that you can use to deploy your dojo world in the testing suite in order to simulate onchain transactions and test the behavior of your world's systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
     // Import helper functions.
     use starknet::ContractAddress;
     // import world dispatcher
     use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};
     // import test utils
     use dojo::utils::test::{spawn_test_world, deploy_contract};
     use dojo::model::Model;
     
     // Deploy world with supplied components registered.
     fn deploy_world() -&gt; IWorldDispatcher {
     
          // Deploy a world with pre-registered models.
          let models: Array&lt;felt252&gt; = array![&lt;name of one of your components&gt;::TEST_CLASS_HASH];
     
          // NOTE: All model names somehow get converted to snake case, but you have to import the
          // snake case versions from the same path where the components are from.
          // Arg 1: Namespace of the world.
          // Arg 2: A span list of all the models' class hashes to register.
         let world: IWorldDispatcher = spawn_test_world(["&lt;name of your project (in Scarb.toml)&gt;"].span(), models.span());
     
         // Deploys a contract with systems.
         // Arg 2: Calldata for constructor.
         let contract_address: ContractAddress =
             world.deploy_contract('salt', &lt;name of your dojo contract&gt;::TEST_CLASS_HASH.try_into().unwrap());
     
         // Grant writing to components.
         // Arg 1: Component selector hash.
         world.grant_writer(Model::&lt;name of one your components&gt;::selector(), contract_address);
         return world;
     }
     
     #[test]
     fn test_join() {
          let mut world = deploy_world();  // Deploy our world.
          let mut my_contract = IMyContractNameDispatcher { contract_address: caller };
          
          // Simulate a caller with a contract address.
          // The next time we call a system in our contract in our deplyed world,
          // the caller will have this contract address.
          let caller = starknet::contract_address_const::&lt;0x0b&gt;();
          
          my_contract.join();
          let _player = get!(world, (caller), (MyModelType));
     }
<span class="boring">}</span></code></pre></pre>
<p>There's also a <em>testing cheat sheet</em> available on the <a href="https://book.dojoengine.org/framework/testing-cheat-codes">Dojo docs</a> if you need to call certain starknet testing functions to further simulate onchain activities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-cheatsheet"><a class="header" href="#test-cheatsheet">Test Cheatsheet</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devnet"><a class="header" href="#devnet">DevNet</a></h1>
<p>Deploying a Dojo world onto devnet using Katana and Torii is pretty straightforward. Couple of things to confirm before proceeding:\</p>
<ul>
<li>Katana is the <strong>sequencer</strong> and to specify where the server will be hosted, the info is in the <strong>dojo-dev.toml</strong> for dev builds and <strong>dojo-release.toml</strong> for release ones, telling sozo where to connect upon <strong>migration</strong></li>
<li>Torii needs the world contract hash of your newly migrated world. It will act as an indexer, receiving any events emitted by the migrated world (from katana)</li>
</ul>
<p>Here's the usual flow when deploying onto your Katana server (assuming your Katana instance is <strong>running</strong>:</p>
<pre><code class="language-bash">$ echo "Cleaning manifests..."
$ sozo clean
$ echo "Building contracts..."
$ sozo build
$ echo "Migrate world onto Katana..."
$ sozo migrate apply
</code></pre>
<p><em>If you ever encounter an issue where it prevents you from migrating because your '<em>project is dirty</em>', make sure to run <strong>sozo clean</strong> and then re-run the command.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-cheatsheet-1"><a class="header" href="#test-cheatsheet-1">Test Cheatsheet</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
